# [←](./README.md) <a id="home"></a> Garbage Collection

## Table of Content:
- [Java Memory](#memory)
- [Garbage collections](#garbage)
- [Serial And Parallel GC](#serialgc)
- [Concurrent Mark Sweep](#cms)
- [G1 Garbage Collector](#g1)
- [java.lang.ref.Reference](#ref)
- [Resources](#resources)

----

## [↑](#home) <a id="memory"></a> Java Memory
Прежде чем говорить про сборку мусора из памяти Java приложения стоит вспомнить про устройство этой самой памяти Java приложения, а точнее JVM.

Перед тем как выполнить Java программу запускается экземпляр JVM, который будет исполнять данную программу. JVM запускается как отдельный процесс, которому выделяется некоторый объеём памяти, называемый **Native Memory**.

Для того, чтобы JVM смогла выполнять Java программу, она загружает набор "базовых" классов. Ранее данные классы хранились в файле **rt.jar**, но начиная с java 9 базовые классы размещены в каталоге lib, а **rj.jar** удалён. Подробнее описано в **"[Migrating From JDK 8 to Later JDK Releases](https://docs.oracle.com/en/java/javase/14/migrate/index.html#JSMIG-GUID-2C896CA8-927C-4381-A737-B1D81D964B7B)"**.

До Java 8 загруженные классы хранились в разделе памяти, который назывался **PermGen** (**Permanent Generation**). Начиная с Java 8 данный раздел заменён на раздел, называемый **Metaspace**, т.к. это раздел, который хранит метаданные. В этом разделе хранятся загруженные классы, байт-код методов, статические поля и методы. Основное отличие от PermGen в том, что размер Metaspace динамически изменяется, в завимисоти от потребности. Кроме того, может быть особая область, называемая "[Compressed Class Space](https://stuefe.de/posts/metaspace/what-is-compressed-class-space/)". Так же немного деталей есть в пункте "Ограничиваем потребление памяти: heap, non-heap, direct memory" в докладе "[Как мы учились эксплуатировать Java в Docker](https://habr.com/ru/company/hh/blog/450954/#lim-mem-1)".

Другой областью в памяти является **Codecache**. Данный раздел памяти содержит код, который был скомпилирован JIT компилятором (так называемые **hot spots**). Подробнее можно прочитать здесь: "[15 Codecache Tuning](https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/codecache.htm)". Иногда можно встретить информацию о том, что codecache - это часть Metaspace, но это неправда. Подтверждением того могут служить обучайющие слайды на сайте Oracle ([HotSpot JVM Memory Management](https://www.oracle.com/webfolder/technetwork/tutorials/mooc/JVM_Troubleshooting/week1/lesson1.pdf)) или раздел "Active Memory pools" в официальной утилите "Java Mission Control".

Есть ещё и другие области, например **Symbols** или **Internal**. В Symbols лежат сигнатуры методов, названия переменных, строки (тот самый "[пул строк](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/String.html#intern())"). В Internal выделяется память под потребности JVM и для [Direct Byte Buffer](https://www.youtube.com/watch?v=0y6_RDga-fk)'ов.

Подробнее про эти секции памяти можно и нужно посмотреть в отличном докладе **"[Андрей Паньгин — Память Java процесса по полочкам](https://www.youtube.com/watch?v=kKigibHrV5I)"**.

Кроме этого, есть область памяти, которая называется **Stack**. Из данной области памяти выделяются стэки для потоков, а так же хранятся локальные переменные и легковесные мониторы. Подробнее про всё это можно прочитать в статье **"[Stack Overflow handling in HotSpot JVM](https://pangin.pro/posts/stack-overflow-handling)"**.

Остаётся только область памяти, называемая кучей, она же **Heap**.
**Heap** - это область памяти, в которой размещаются объекты. У каждого объекта есть своё время жизни. Когда объект больше не нужен нужно освободить от него память, чтобы дать возможность использовать эту же память, но под нужные объекты. И тут на помощь приходят сборщики мусора, они же Garbage Collector'ы.



## [↑](#home) <a id="garbage"></a> Garbage collections
Сборка мусора состоит из разных фаз, но любой сборщик мусора должен понять, какой объект живой, а какой "мусор".

Чтобы найти живые объекты нужно определить отправные точки, от которых будет обходиться граф объектов. Такие точки называются **GC Roots**.

**GC Roots** - это корневые элементы графа, с которых выполняется поиск живых объектов. Подсмотрев в материал **"[Garbage Collection in Java](https://www.w3resource.com/java-tutorial/garbage-collection-in-java.php)"** можно узнать, что к таким элементам относятся:
- локальные переменные (local variables)
- активные потоки (active threads)
- статические переменные (static variables)
- JNI ссылки (т.е. ссылки из вызываемого native кода)

Чтобы найти и пометить все доступные GC Roots и напрямую доступные из них объекты необходимо выполнить остановку приложения. Такие паузы называют **Stop-the-world** паузами или же коротко **STW**. Сделать такую остановку можно не в любой момент времени, а в так называемых **Safepoint**'ах. Подробнее про Safepoint можно послушать в докладе **"[Андрей Паньгин — Safepoint — и пусть весь мир подождёт](https://www.youtube.com/watch?v=rthWVvU9gWo)"**. Основной смысл таких точек остановки - в них известно состояние потока, который будет остановлен (подробнее см. "[JVM Anatomy Quark #22: Safepoint Polls](https://shipilev.net/jvm/anatomy-quarks/22-safepoint-polls/)"). Точки зависят от того, интерпритируется ли код или он скомпилирован JIT компилятором. В случае интерпритатора мы можем останавливаться между любыми байткод инструкциями. В случае скомпилированного кода такими точками являются места перед выходом из метода и перед выходом из цикла, а так же места вызова VM Runtime.

Говоря про сборку мусора стоит сказать, что в основной своей части сборщики мусора опираются на **[слабую гипотезу о поколениях](https://youtu.be/ZYiQCHxgABI?t=2574)**.
**Cлабая гипотеза о поколениях** говорит о том, что большинство создаваемых объектов не живут долго и умирают молодыми. На основе этого можно разделить объекты по времени жизни и сделать упор на обработку прежде всего молодых объектов, отложив в сторону более долгоживущие объекты.

На основе этой гипотезы сборки разделяют на малые сборки (**minor GC**) и на полные сборки (**full GC**). Малые сборки обрабатывают только молодые объекты, чтобы каждый раз не смотреть все объекты.

В том числе сборщики мусора не только про удаление объектов, но и про размещение объектов в Heap. Сборщики мусора разделяют Heap на некоторые участки (как минимум логически), деля их на такие типы, как:
- **Eden** (Эдем): здесь живут вновь созданные объекты
- **Survivor** : здесь живут объекты, которые пережили некоторое число сборок, но при этом ещё считаются молодыми
- **Tenured** : здесь размещены объекты, которые живут уже долго.

Говоря про Eden можно так же вспомнить и про **[TLAB](https://dzone.com/articles/thread-local-allocation-buffers)** для полной картины.

Про сборку мусора и байтбуферы стоит так же почитать интересный вопрос: **"[How Java GC Does Direct Byte Buffer Clean Up, Because IBM Docs says, It Does.](https://stackoverflow.com/questions/40122063/how-java-gc-does-direct-byte-buffer-clean-up-because-ibm-docs-says-it-does)"**.

То, каким образом организованы данные типы областей размещения объектов, как объекты размещаются и удаляются, зависит от реализации сборщиков мусора.



## [↑](#home) <a id="serialgc"></a> Serial And Parallel GC
Один из самых известных сборщиков мусора - **Serial GC**. Данный сборщик мусора использовался в Java 8 по умолчанию. Данный сборщик мусора отлично описан в статье **"[Дюк, вынеси мусор! — Часть 2](https://habr.com/ru/post/269707/)"**.

При Serial GC хип делится на регионы. Все новые объекты попадают в регион, который называется **"Eden"** (Эдем). Когда в Эдеме становится слишком тесно, тогда запускается малая сборка (**minor GC**). При такой сборке все "мёртвые" объекты удаляются из Эдема.

Кроме Эдема есть два **Survivor** региона для выживших после minor GC. Один из этих регионов всегда пустой и используется для перемещения в него всех выживших из Эдема и из другого Survivor региона. Таким образом выжившие объекты перемещаются то в один Survivor регион, то в другой.

Перемещение между Survivor не бесконечно. Если объект переживает определённое количество таких перемещений, то он перемещается в последний из доступных для перемещения регионов - **Tenured** (бессрочный).

Когда место кончается даже в Tenured, то тогда происходит полная сборка мусора (**full GC**), которая гораздо более ресурсозатратная, чем Minor GC.

Как можно догадаться из названия, данный сборщик мусора делает всё последовательно. Но у него есть альтернатива - **Parallel GC**.

**Parallel GC** - это Serial GC, который работает в несколько потоков и с некоторыми улучшениями. Количество потоков высчитывается с учётом кол-ва ядер процессора. Каждому потоку выделяют свой участок в регионе **Old Gen** (тут так называется Tenured). Такой участок называется **promotion buffer**.

Parallel GC ведёт статистику и на основе неё может делать некоторые оптимизации, чтобы максимально попытаться уложиться в заданные параметры максимального времени сборки и пропускной способности. Данные параметры могут быть заданы при помощи опций JVM ``-XX:MaxGCPauseMillis`` и ``-XX:GCTimeRatio``.



## [↑](#home) <a id="cms"></a> Concurrent Mark Sweep
Как альтернативу Parallel GC создали сборщик CMS (Concurrent Mark Sweep).
Про данный сборщик можно прочитать в материале **"[Дюк, вынеси мусор! — Часть 3](https://habr.com/ru/post/269863/)"**. Данный сборщик использует ту же организацию памяти, т.е. ту же разбивку на Eden + Survivor 0 + Survivor 1 + Tenured и те же принципы сборки мусора. Таким образом, можно сказать, что **minor** сборка одинакова для Serial, Parallel и CMS сборщиков.

Отличия для CMS начинаются на full GC, которая здесь называется **major GC**. Называется она не full, потому что затрагивает только старшее поколение (т.е. только Tenured). Сайд эффект в этом может заключаться в том, что мусор из младшего поколения не даст очистить мусор из старшего поколения.

Отличие CMS в том, что он работает постоянно в фоном режиме, а не дожидается заполнения Tenured региона. Сборщик CMS выполняет major сборку не за 1 заход, а за два. За каждый заход сборщик помечает напрямую доступные из GC Root объекты, после чего приложение продолжает работу, а сборщик в фоновом режиме продолжает искать живые объекты. Потом повторяет ту же работу, чтобы найти тех, кто был пропущен за первый прогон. После чего приложение возвращается к работе, а сборщик очищает найденный мусор.

В текущий момент CMS сборщик имеет статус Deprecated (см. **"[JEP 291: Deprecate the Concurrent Mark Sweep (CMS) Garbage Collector](https://openjdk.java.net/jeps/291)"**). Причина - уменьшить кодовую базу, так как для большинства случаев CMS может и должен быть заменён сборщиком G1.



## [↑](#home) <a id="g1"></a> G1 Garbage Collector
Начиная с Java 9 сборщиком по умолчанию является **G1 Garbage Collector**.
Про данный сборщик можно прочитать тут: **"[Дюк, вынеси мусор! — Часть 3](https://habr.com/ru/post/269863/)"**.

Регионы тоже имеют тип Eden, Survivor и Tenured, но теперь их много. Их размер выбирается так, чтобы регионов было не больше 2048. Но бывают случаи, когда регионы объединяются в больший регион, чтобы там был очень большой объект. Такие регионы называются "громадные" (humongous).

Разделение регионов на Eden, Survivor и Tenured теперь логическое, регионы одного поколения не обязаны идти подряд и даже могут менять свой тип.

С некоторой периодичностью выполняются Minor сборки, во время которых живые объекты переносятся в Survivor, либо переносятся в Tenured. Перенос выполняется в несколько потоков (как в Parallel GC) с остановкой приложения.

При Minor GC очистка выполняется не на всём поколении, а только в части регионов так, чтобы не привысить желаемое время сборки. При этом GC пытается выбрать именно те, где может скопиться наибольшее количество "мёртвых" объектов. Поэтому и название G1, то есть Garbage First, т.е. "сперва мусор".

Полная сборка в G1 именуется смешанной (**mixed**), т.к. на самом деле такая очистка выполняется вместе с малой сборкой, если выполнение полной сборки необходимо. Решение об этом принимается на основании статистики о прошлых сборках. Перед тем, как включить смешанную сборку GC выполняет цикл пометки, который называется **Marking Cycle**.

Данный сборщик мусора использует тактику, которая называется **Snapshot-At-The-Beginning**. Это означает, что сборщик мусора запоминает состояние на начало сборки мусора, после чего отслеживает изменение этого снимка (т.е. новые объекты + изменение связей).

**Marking Cycle** (Цикл пометки) - особая фаза, которая выполняется параллельно с работой приложения. Состоит из нескольких шагов, часть из которых выполняется с остановкой приложения.

Выполняемые шаги:
1. **Initial mark** - остановка приложения для пометки GC Root. При этом используется статистика, полученная при выполнении малых сборок.
2. **Concurrent marking** - возобновление приложения, после которой в нескольких потоках помечаются все живые объекты в куче.
3. **Remark** - опять останавливается приложение (как в CMS), чтобы попробовать найти ещё живые объекты.
4. **Cleanup** - очищаем вспомогательные структуры (для учёта ссылок на объекты) и ищем пустые регионы, которые можно использовать для размещения объектов.

Когда данные шаги будут выполнены GC переключится в режим выполнения смешанных сборок, во время которых будут убираться мусор не только из младших поколений. То, какое количество старших регионов очищать выбирается на основе статистики. В том числе, на основе этой статистики GC будет решать, когда перестать работать в режиме смешанных сборок.



## [↑](#home) <a id="finalize"></a> Finalize
Говоря про сборку мусора нужно помнить про такой метод из класса Object, который называется **[finalize](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Object.html#finalize())**.

Данный метод можно переопределить у любого класса и тогда при сборке мусора объект, который является мусором, не будет так просто удалён. Такой объект будет помещён в особую очередь ReferenceQueue в особом фоновом потоке Finalizer, который поочерёдно из этой очереди достаёт такие объекты, вызывает на каждом из них **finalize()**. После этого такие объекты станут доступны для сборки.

Только из этого описания уже видны недостатки:
- Объекты, в классе которых есть finalize, собираются за 2 сборки мусора
- Чем больше объектов в очереди Finalizer, тем дольше начинают жить объекты, который мусор
- Метод finalize - это просто обычный метод. Таким образом реализации могут "потерять" логику из супер класса, если забудут вызвать finalize у super
- В случае исключений в finalize финализация может не завершится и объект останется в неконсистентном состоянии, а ресурсы не будут освобождены
- Нет гарантий, в какой момент времени и в каком порядке будут вызваны finalize методы у разных объектов

Подробнее можно посмотреть в докладе "[Вы всё ещё используете finalize()? Тогда мы идём к вам](https://www.youtube.com/watch?v=K5IctLPem0c)".

Таким образом механизм finalize стоит избегать. Начиная с Java 9 на замену пришёл **[java.lang.ref.Cleaner](https://bugs.openjdk.java.net/browse/JDK-8138696)**.

Разговоры про Finalize и про сборку непримернно приводят к разговору и про такой интересный инструмент как **[java.lang.ref.Reference](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/ref/Reference.html)**.



## [↑](#home) <a id="ref"></a> java.lang.ref.Reference
В Java есть особый абстрактный класс, который представляет из себя ссылку на объект. Реализации этого класса обрабатываются особым образом сборщиками мусора. Каждая реализация описывает различный уровень "силы" ссылки. Эта сила влияет на то, при каких обстоятельствах объект, на который ведёт ссылка, будет собран сборщиком мусора.

Стоит помнить, что обычное присвоение ссылки на объект является "сильной" ссылкой (**Strong**). То есть пока ссылка есть - объект не соберут. Это самаое строгое обязательство.

Как антоним, для "сильных ссылок" есть "слабые ссылки" (**Weak Reference**).
**Weak Reference** - это ссылка, которая не удерживает объект от сборки GC. Как пример использования - карты **WeakHashMap**, где значения из карты удаляются тогда, когда ключи уже не используются (с оговоркой, что значения не должны держать ключи).

По середине между **Strong** и **Weak** стоит **Soft**. **Soft Reference**, т.е. "мягкие ссылки", собираются сборщиком только тогда, когда памяти начнёт нехватать. Если памяти хватает, а объекты уже никем не используются, то они остаются жить. Подробнее см. **"[Guidelines for using the Java 2 reference classes](https://www.ibm.com/developerworks/library/j-refs/)"**.

И самые необычные Reference - **PhantomReference**. **PhantomReference** - это фантомные ссылки. Такие ссылки необычны тем, что всегда возвращают null вместо объекта и нужны в основном для того, чтобы такие Reference использовать для отслеживания сборки объектов, т.к. фантомные ссылки поступают в ReferenceQueue когда объекты собраны (именно поэтому они возвращают null всегда).



## [↑](#home) <a id="resources"></a> Resources
Дополнительные материалы:
- [Understanding Java Garbage Collection Logging](https://sematext.com/blog/java-garbage-collection-logs/#toc-how-to-enable-gc-logging-3)
- [Troubleshooting Memory Problems in Java Applications](https://www.youtube.com/watch?v=iixQAYnBnJw)
- [Do Your GC Logs Speak to You?](https://www.youtube.com/watch?v=Miwga8-dx0A)