# [←](../README.md) <a id="home"></a> Object-Oriented Programming

Java является объектно-ориентированным языком, основанным на следующих принципых ООП: Инкапсуляция, Наследования, Абстракция и Полиморфизм.

## Table of Contents:
- [Incapsulation](#incapsulation)
- [Inheritance](#inheritance)
- [Abstraction](#abstraction)
- [Polymorphism](#polymorphism)
- [Inner Classes](#inner)
- [SOLID](#solid)

----

## [↑](#home) <a id="incapsulation"></a> Incapsulation
Принцип инкапсуляции описывает сокрытие реализации и организации доступа к объекту только через специальные публичные и поля.

Для организации доступа классы объединяются в пакеты (**[packages](https://docs.oracle.com/javase/tutorial/java/package/packages.html)**).\
Если пакет не указан, то класс помещается в **Unnamed Packages**, который предоставляется JVM. Однако, такие пакеты не могут иметь подпакеты, т.к. подпакеты подразумевают наличие имени у родительского пакета.

Принцип инкапсуляции реализуется при помощи **Модификаторо доступа (Access Modifiers)**:
- **private** : видимость только на уровне текущего класса и нигде за его пределами
- **package private** (модификатор не указан) : видимость на уровне класса и его пакета
- **protected** : видимость на уровне класса и его наследников
- **public** : видно всем


## [↑](#home) <a id="inheritance"></a> Inheritance
Наследование - очень важный принцип. Классы могут быть унаследованны от других классов, перенимая их поведение.

Унаследованы могут быть только классы, которые видимы для текущего класса и который не помечены ключевым словом **final**.

Наследники могут переопределять методы родителя, при этом их видимость может быть расширена, но не сужена:
```java
public class Example {
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```
При этому наследники могут обращаться к своему непосредственному родителю через ключевое слово **super**. Т.к. родитель - это **Superclass**.\
Обращение из класса к самому себе происходит при помощи ключевого слова **this**.

Говоря про наследование стоит помнить, что при создании наследника сначала инициализируется статическая часть родителя, потом статическая часть наследника. Потом нестатическая часть родителя, потом конструктор родителя, а уже потом нестатическая часть наследника. Завершается всё конструктором наследника. Кроме этого, стоит помнить что конструкторы не наследуются.


## [↑](#home) <a id="abstraction"></a> Abstraction
Абстракция - один из важных принципов, связывающих остальные принципы.

Помимо классов в Java могут быть объявлены абстрактные классы (классы с ключевым словомо abstract) и интерфейсы.\
Абстрактные классы и интерфейсы могут иметь методы без тела. Эти методы должны быть реализованы в наследниках.

Согласно документации Oracle, [интерфейсы](https://docs.oracle.com/javase/tutorial/java/concepts/interface.html) описывают поведение объекта.\
Например, в Java есть интерфейс **java.lang.Iterable**, благодаря которому можно понять, что у такого объекта можно запросить итератор, чтобы пройтись по содержимому. Т.к. интерфейс - это про поведение, то в интерфейсе могут быть только статические переменные (они вспомогательные и к состоянию объекта не относятся).

Интересная особенность интерфейсов - они могут наследоваться от нескольких интерфейсов:
```java
interface MainInterface extends inter1, inter2, inter3 {  
  // methods
}
```

Начиная с Java 8 в интерфейсах появилась возможность создавать методы с телом (**default method'ы**) и статические методы.\
Начиная с Java 9 в интерфейсах появились приватные методы.

Абстрактные классы в отличии от интерфейсов не только про поведение, поэтому это почти что полноценный класс, за исключением того, что его экземпляр не может быть создан (т.к. абстрактный класс предполагает возможность наличие методов, которые не определены).


## [↑](#home) <a id="polymorphism"></a> Polymorphism
Полиморфизм позволяет добиться гибкости выполнения программы.\
Полиморфизм использует механизм позднего связывания и принцип абстракции для своей реализации.

Самый простой пример полиморфизма: метод на вход принимает тип, а ему передают туда разные реализации. Например:
```java
interface Messenger {
    public void send(String msg);
}

public void sendToMessenger(Messenger messenger) {
    messenger.send("Error");
}
```


## [↑](#home) <a id="inner"></a> Inner Classes
Внутренние классы - это классы внутри классов.

Особенность внутренних классов в том, что они попадают в область видимости внешнего класса.\
Это значит, что у нас может быть приватный внутренний класс.

Внутренние классы могут быть статическими (**Nested classes**) и нет (**Inner classes**).\
Особенность внутренних классов в том, что они знают и видят свой внешний класс. Это позволяет из методов внутренних классов обращаться к тому, через кого их создали:
```java
public class T1 {
    private String name = "name";
    public class Messenger {
        public void send(String msg) {
            System.out.println(T1.this.name);;       
        }
    }
```


## [↑](#home) <a id="solid"></a> SOLID
Говоря про объектно-ориентированное программирование стоит помнить про аббревиатуру SOLID.

**Single Responsibility Principle**\
Принцип единственной ответственности гласит о том, что у каждого класса должно быть только одно назначение. Например, если парсер XML не должен отвечать в том числе за экспорт результата.

**Open-closed principle**\
Данный принцип говорит, что код должен быть открыт для расширения, но закрыт для изменения.\
Смутное описание, но на практике его нарушить просто. Самый яркий пример - метод, который на основе типа полученного аргумента что-то делает. Это приводит к тому, что при добавлении нового класса придётся добавлять новую ветку в if.

**Liskov substitution principle**\
Данный принцип гласит: 
> Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы

**Interface segregation principle**\
Принцип единственной ответственности, переложенный на интерфейсы. Идея в том, что не должно быть одного гигантского интерфейса про не связанные действия, а должно быть несколько интерфейсов описывающих определённые аспекты поведения класса.

**Dependency inversion principle**\
Важный принцип, который гласит, что нижние уровни не должны зависеть от верхних. Абстракции не должны зависеть от деталей.\
В случае нарушения данного принципа при изменении деталей реализации нижестоящих модулей может потребоваться изменять вышестоящие уровни. Это будет явным признаком нарушения SOLID.